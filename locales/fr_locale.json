{
  "main": {
    "app_start": "======================================D√©marrage de l'application======================================\n\n",
    "app_end": "=================================Arr√™t de l'application================================\n\n"
  },
  "main_window": {
    "app_started": "======================================Application d√©marr√©e====================================\n\n",
    "app_title": "G_A_P_V.2",
    "default_graph_name": "Graphe 1"
  },
  "ford_fulkerson": {
    "directed_error": "L'algorithme de Ford-Fulkerson ne fonctionne qu'avec les graphes orient√©s.",
    "weight_error": "Toutes les ar√™tes doivent avoir des poids non n√©gatifs pour l'algorithme de Ford-Fulkerson.",
    "init_info": "Initialisation FordFulkerson : le graphe est orient√©, tous les poids d'ar√™tes sont corrects.",
    "max_flow_log_info": "Flux maximum entre {source_id} et {sink_id} : {max_flow}"
  },
  "min_cut": {
    "directed_error": "L'algorithme de coupe minimale ne fonctionne qu'avec les graphes orient√©s.",
    "weight_error": "Toutes les ar√™tes doivent avoir des poids non n√©gatifs pour l'algorithme de coupe minimale.",
    "init_info": "Initialisation MinCut : le graphe est orient√©, tous les poids d'ar√™tes sont corrects.",
    "min_cut_start": "Recherche de coupe minimale entre {source_id} et {sink_id} commenc√©e.",
    "min_cut_found_path": "Chemin trouv√© avec flux {path_flow}. Flux max actuel : {max_flow}",
    "min_cut_end": "Coupe minimale : {max_flow}, nombre d'ar√™tes dans la coupe : {len_cut_edges}"
  },
  "bellman_ford": {
    "weight_error": "Toutes les ar√™tes doivent avoir des poids pour l'algorithme de Bellman-Ford.",
    "init_info": "Initialisation BellmanFord : tous les poids d'ar√™tes sont corrects.",
    "bellman_ford_start": "Recherche des chemins les plus courts depuis le sommet {start_id} commenc√©e.",
    "update_path": "Chemin mis √† jour vers {v} : distance {d}, pr√©d√©cesseur {u}",
    "enable_negative_cycles": "Le graphe contient un cycle n√©gatif.",
    "bellman_ford_end": "Recherche des chemins les plus courts termin√©e."
  },
  "dijkstra": {
    "weight_error": "Toutes les ar√™tes doivent avoir des poids non n√©gatifs pour l'algorithme de Dijkstra.",
    "init_info": "Initialisation Dijkstra : tous les poids d'ar√™tes sont corrects.",
    "dijkstra_start": "Recherche des chemins les plus courts depuis le sommet {start_id} commenc√©e.",
    "update_path": "Chemin mis √† jour vers {v_id} : distance {alt}, pr√©d√©cesseur {u_id}",
    "dijkstra_end": "Recherche des chemins les plus courts termin√©e."
  },
  "floyd_warshall": {
    "weight_error": "Toutes les ar√™tes doivent avoir des poids non n√©gatifs pour l'algorithme de Floyd-Warshall.",
    "init_info": "Initialisation FloydWarshall : tous les poids d'ar√™tes sont corrects.",
    "floyd_warshall_start": "Ex√©cution de l'algorithme Floyd-Warshall commenc√©e.",
    "update_path": "Chemin mis √† jour {from_node} ‚Üí {to_node} via {via_node} : distance {distance}",
    "floyd_warshall_end": "Algorithme Floyd-Warshall termin√©."
  },
  "kruskal": {
    "directed_error": "L'algorithme de Kruskal ne fonctionne qu'avec les graphes non orient√©s.",
    "weight_error": "Toutes les ar√™tes doivent avoir des poids non n√©gatifs pour l'algorithme de Kruskal.",
    "init_info": "Initialisation Kruskal : le graphe est non orient√©, tous les poids d'ar√™tes sont corrects.",
    "kruskal_start": "Recherche de l'arbre couvrant minimal commenc√©e.",
    "update_path": "Ar√™te ({u}, {v}) avec poids {edge_weight} ajout√©e au MST.",
    "connected_warn": "Le graphe n'est pas connexe ‚Äî le MST n'existe pas pour tous les sommets.",
    "kruskal_end": "Termin√©. Poids du MST : {total_weight}, nombre d'ar√™tes : {len_mst_edges}"
  },
  "prim": {
    "directed_error": "L'algorithme de Prim ne fonctionne qu'avec les graphes non orient√©s.",
    "weight_error": "Toutes les ar√™tes doivent avoir des poids non n√©gatifs pour l'algorithme de Prim.",
    "init_info": "Initialisation Prim : le graphe est non orient√©, tous les poids d'ar√™tes sont corrects.",
    "prim_start": "Recherche de l'arbre couvrant minimal (MST) commenc√©e.",
    "update_path": "Ar√™te ({edge_source_id}, {edge_target_id}) avec poids {weight} ajout√©e au MST.",
    "connected_warn": "Le graphe n'est pas connexe ‚Äî le MST n'existe pas pour tous les sommets.",
    "prim_end": "Termin√©. Poids du MST : {total_weight}, nombre d'ar√™tes : {len_mst_edges}"
  },
  "eulerian_path_finder": {
    "methods_error": "Le graphe doit avoir les m√©thodes nodes, edges et neighbors.",
    "components_error": "Le graphe doit contenir au moins un sommet et une ar√™te.",
    "init_info": "Initialisation EulerianPathFinder : le graphe est correct.",
    "eulerian_start": "Recherche de chemin eul√©rien commenc√©e.",
    "enable_eulerian_warn": "Le chemin eul√©rien n'existe pas dans le graphe.",
    "enable_eulerian_not_all_edges_used_warn": "Toutes les ar√™tes ne sont pas utilis√©es ‚Äî le chemin eul√©rien n'existe pas.",
    "eulerian_end": "Chemin eul√©rien trouv√© : {path_str}"
  },
  "hamiltonian_path_finder": {
    "methods_error": "Le graphe doit avoir les m√©thodes nodes, edges et neighbors.",
    "enable_node_error": "Le graphe ne contient aucun sommet.",
    "init_info": "Initialisation HamiltonianPathFinder : le graphe est correct.",
    "hamiltonian_start": "Recherche de chemin hamiltonien entre {start_id} et {end_id} commenc√©e.",
    "start_end_error": "Le sommet de d√©part ou d'arriv√©e n'est pas pr√©sent dans le graphe.",
    "hamiltonian_end": "Chemin hamiltonien trouv√© : {path_str}",
    "enable_path_warn": "Le chemin hamiltonien entre {start_id} et {end_id} n'existe pas."
  },
  "longest_path_finder": {
    "methods_error": "Le graphe doit avoir les m√©thodes nodes, edges et neighbors.",
    "enable_node_error": "Le graphe ne contient aucun sommet.",
    "init_info": "Initialisation LongestPathFinder : le graphe est correct.",
    "longest_start": "Recherche du chemin simple le plus long entre {start_id} et {end_id} commenc√©e.",
    "start_end_error": "Le sommet de d√©part ou d'arriv√©e n'est pas pr√©sent dans le graphe.",
    "longest_end": "Chemin simple le plus long trouv√© : {path_str} (longueur {len_longest_path})",
    "enable_path_warn": "Le chemin simple le plus long entre {start_id} et {end_id} n'existe pas."
  },
  "simple_path_finder": {
    "methods_error": "Le graphe doit avoir les m√©thodes nodes, edges et neighbors.",
    "enable_node_error": "Le graphe ne contient aucun sommet.",
    "init_info": "Initialisation SimplePathFinder : le graphe est correct.",
    "simple_start": "Recherche de chemin simple entre {start_id} et {end_id} commenc√©e.",
    "start_end_error": "Le sommet de d√©part ou d'arriv√©e n'est pas pr√©sent dans le graphe.",
    "simple_end": "Chemin simple trouv√© : {path_str}",
    "enable_path_warn": "Le chemin simple entre {start_id} et {end_id} n'existe pas."
  },
  "bfs": {
    "methods_error": "Le graphe doit avoir les m√©thodes nodes et neighbors.",
    "nodes_error": "Le graphe ne contient aucun sommet.",
    "init_info": "Initialisation BFS : le graphe est correct.",
    "bfs_start": "BFS commen√ßant depuis le sommet {start_id}.",
    "start_error": "Le sommet de d√©part n'est pas pr√©sent dans le graphe.",
    "bfs_end": "BFS termin√©. Ordre de parcours : {path_str}"
  },
  "dfs": {
    "methods_error": "Le graphe doit avoir les m√©thodes nodes et neighbors.",
    "nodes_error": "Le graphe ne contient aucun sommet.",
    "init_info": "Initialisation DFS : le graphe est correct.",
    "dfs_start": "DFS commen√ßant depuis le sommet {start_id}.",
    "start_error": "Le sommet de d√©part n'est pas pr√©sent dans le graphe.",
    "dfs_end": "DFS termin√©. Ordre de parcours : {path_str}"
  },
  "traversal_algorithms": {
    "bfs_start": "BFS commence depuis le sommet {start_id}",
    "bfs_update": "BFS a visit√© le sommet {node_id}",
    "bfs_end": "BFS termin√©. Ordre : {order}",
    "dfs_start": "DFS commence depuis le sommet {start_id}",
    "dfs_update": "DFS a visit√© le sommet {node_id}",
    "dfs_end": "DFS termin√©. Ordre : {order}",
    "dijkstra_start": "Dijkstra commence depuis le sommet {start_id}",
    "dijkstra_update": "Dijkstra a visit√© le sommet {node_id} (distance {dist})",
    "dijkstra_end": "Dijkstra termin√©. Ordre : {order}",
    "comp_start": "Recherche des composantes connexes commence",
    "comp_update": "Composante trouv√©e : {comp}",
    "comp_end": "Recherche des composantes connexes termin√©e. Total des composantes : {len_components}",
    "cycle_start": "D√©tection de cycle commence",
    "cycle_update": "Cycle trouv√© : {cycle}",
    "cycle_end": "D√©tection de cycle termin√©e. Ordre : {order}, Nombre de cycles : {len_cycles}"
  },
  "graph_info": {
    "num_nodes": "Nombre de sommets",
    "num_edges": "Nombre d'ar√™tes",
    "min_degree": "Degr√© minimal",
    "max_degree": "Degr√© maximal",
    "avg_degree": "Degr√© moyen",
    "is_connected": "Graphe connexe",
    "structural_redundancy": "Redondance structurelle",
    "degree_inequality": "In√©galit√© de distribution des connexions",
    "structural_compactness": "Compacit√© structurelle",
    "relative_compactness": "Indicateur de compacit√© relative",
    "degree_centralization": "Centralisation de degr√©",
    "yes": "Oui",
    "no": "Non"
  },
  "edge_converter": {
    "not_directed_error": "L'ar√™te pass√©e n'est pas orient√©e.",
    "directed_to_undirected_info": "Ar√™te orient√©e ({source_id} -> {target_id}) convertie en non orient√©e.",
    "not_undirected_error": "L'ar√™te pass√©e n'est pas non orient√©e.",
    "undirected_to_directed_info": "Ar√™te non orient√©e ({source_id} -- {target_id}) convertie en orient√©e ({new_source_id} -> {new_target_id})."
  },
  "graph_converter": {
    "directed_to_undirected_info": "Graphe orient√© converti en non orient√©.",
    "undirected_to_directed_info": "Graphe non orient√© converti en orient√©."
  },
  "base_edge": {
    "repr_format": "{class_name}(source={source}, target={target}, data={data})"
  },
  "node": {
    "created_info": "Sommet cr√©√© : id={node_id}, data={data}, position={pos}",
    "repr_format": "Node(id={node_id}, data={data}, position={pos})"
  },
  "directed_edge": {
    "created_info": "Ar√™te orient√©e cr√©√©e : source={source_id}, target={target_id}, weight={weight}, data={data}"
  },
  "undirected_edge": {
    "created_info": "Ar√™te non orient√©e cr√©√©e : node1={node1_id}, node2={node2_id}, weight={weight}, data={data}"
  },
  "directed_graph": {
    "nodes_not_in_graph_error": "Les deux sommets de l'ar√™te doivent √™tre ajout√©s au graphe avant d'ajouter l'ar√™te."
  },
  "undirected_graph": {
    "nodes_not_in_graph_error": "Les deux sommets de l'ar√™te doivent √™tre ajout√©s au graphe avant d'ajouter l'ar√™te."
  },
  "graph_loader": {
    "success_load": "Graphe charg√© avec succ√®s depuis le fichier {filepath}",
    "error_load": "Erreur lors du chargement du graphe : {error}"
  },
  "graph_saver": {
    "success_save": "Graphe sauvegard√© avec succ√®s dans le fichier {filepath}",
    "error_save": "Erreur lors de la sauvegarde du graphe : {error}"
  },
  "session_exporter": {
    "export_start": "D√©but de l'export de session vers le fichier : {filepath}",
    "export_success": "Session export√©e avec succ√®s vers le fichier : {filepath}",
    "export_error": "Erreur lors de l'export de session : {error}"
  },
  "session_importer": {
    "import_start": "D√©but de l'import de session depuis le fichier : {filepath}",
    "class_not_found_warning": "Classe de graphe {class_name} non trouv√©e dans graph_class_map",
    "edge_nodes_not_found_warning": "Sommets non trouv√©s pour l'ar√™te : {edge_info}",
    "import_success": "Session import√©e avec succ√®s depuis le fichier : {filepath}",
    "import_error": "Erreur lors de l'import de session : {error}"
  },
  "txt_exporter": {
    "export_error": "Erreur lors de l'export vers .txt : {error}"
  },
  "graph_canvas": {
    "undo_tooltip": "Annuler la derni√®re action (Annuler, Ctrl+Z)",
    "redo_tooltip": "Refaire l'action (Refaire, Ctrl+Y)"
  },
  "edge_edit_dialog": {
    "window_title": "Ajouter/Modifier une Ar√™te",
    "weight_label": "Poids de l'ar√™te :",
    "additional_data_label": "Donn√©es suppl√©mentaires (cl√©-valeur) :",
    "key_label": "Cl√© :",
    "value_label": "Valeur :",
    "ok_button": "OK",
    "cancel_button": "Annuler"
  },
  "graph_select_dialog": {
    "window_title": "S√©lection de Graphe",
    "select_graph_label": "S√©lectionner le graphe √† utiliser :",
    "new_graph_button": "Nouveau Graphe",
    "delete_graph_button": "Supprimer Graphe",
    "select_button": "S√©lectionner",
    "export_session_button": "Exporter Session",
    "import_session_button": "Importer Session",
    "directed": "Orient√©",
    "undirected": "Non orient√©",
    "weighted": "Pond√©r√©",
    "unweighted": "Non pond√©r√©",
    "graph_type_title": "Type de Graphe",
    "graph_type_label": "S√©lectionner le type de graphe :",
    "weight_title": "Poids",
    "weight_label": "Le graphe est-il pond√©r√© ?",
    "auto_name_title": "Nommage automatique des sommets",
    "auto_name_label": "Utiliser des noms automatiques pour les sommets ?",
    "graph_name_title": "Nom du Graphe",
    "graph_name_label": "Entrer le nom du graphe :",
    "yes": "Oui",
    "no": "Non",
    "delete_warning_title": "Supprimer",
    "delete_active_graph": "Impossible de supprimer le graphe actif. Veuillez d'abord en s√©lectionner un autre.",
    "delete_no_selection": "S√©lectionner un graphe √† supprimer.",
    "select_warning_title": "S√©lection",
    "select_no_selection": "S√©lectionner un graphe dans la liste.",
    "export_session_title": "Exporter Session",
    "import_session_title": "Importer Session",
    "session_files": "Fichiers de Session (*.json)"
  },
  "instruction_dialog": {
    "window_title": "Instructions",
    "instruction_text": "‚ÑπÔ∏è  Instructions : Cr√©ation et √©dition de graphes\n\n--- ACTIONS DE BASE ---\n‚Ä¢ Ajouter un sommet : Clic gauche sur un espace vide du canevas\n‚Ä¢ Supprimer un sommet : Clic droit sur le sommet\n‚Ä¢ D√©placer un sommet : Clic gauche sur le sommet et glisser avec la souris\n‚Ä¢ S√©lectionner un sommet : Clic gauche sur le sommet (met en surbrillance pour cr√©er une ar√™te)\n\n‚Ä¢ Ajouter une ar√™te : S√©lectionner le premier sommet, puis Ctrl+clic gauche sur le second sommet\n‚Ä¢ Supprimer une ar√™te : Clic droit sur le milieu d'une ar√™te\n‚Ä¢ Modifier le poids/donn√©es d'une ar√™te : Double-clic sur le milieu d'une ar√™te (graphes pond√©r√©s uniquement)\n‚Ä¢ S√©lectionner une ar√™te : Clic gauche sur le milieu d'une ar√™te\n\n--- PARAM√àTRES ---\n‚Ä¢ Type de graphe (orient√©/non orient√©) : Commutateur au-dessus du canevas\n‚Ä¢ Poids du graphe (pond√©r√©/non pond√©r√©) : Commutateur au-dessus du canevas\n‚Ä¢ Nommage automatique des sommets : Commutateur au-dessus du canevas\n‚Ä¢ Nommage manuel : Lorsque d√©sactiv√©, une bo√Æte de dialogue appara√Æt pour les noms personnalis√©s\n\n--- IMPORT/EXPORT ---\n‚Ä¢ Exporter le graphe : Utilisez les boutons d'export .json/.txt sous le canevas\n‚Ä¢ Importer le graphe : Utilisez le bouton 'Importer depuis .json' sous le canevas\n‚Ä¢ Sauvegarder la session : Exporter plusieurs graphes et param√®tres\n\n--- GESTION DES GRAPHES ---\n‚Ä¢ Le bouton 'S√©lectionner Graphe' ouvre la fen√™tre de gestion des graphes\n‚Ä¢ Cr√©er, renommer, supprimer ou dupliquer des graphes\n‚Ä¢ Travailler avec plusieurs graphes dans une session\n‚Ä¢ Basculer facilement entre les graphes\n\n--- OUTILS D'ANALYSE ---\n‚Ä¢ Chemins les plus courts : Algorithmes de Dijkstra, Bellman-Ford, Floyd-Warshall\n‚Ä¢ Arbres couvrants : Algorithmes de Prim et Kruskal\n‚Ä¢ Chemins sp√©ciaux : Chemins simples, plus longs, hamiltoniens, eul√©riens\n‚Ä¢ Parcours de graphe : BFS, DFS, composantes connexes, d√©tection de cycles\n‚Ä¢ Algorithmes de flot : Flot maximum de Ford-Fulkerson, coupe minimale\n‚Ä¢ Vue matricielle : Matrices d'adjacence et d'incidence\n\n--- FONCTIONNALIT√âS SUPPL√âMENTAIRES ---\n‚Ä¢ Th√®mes : Personnaliser l'apparence de l'interface\n‚Ä¢ Langues : Basculer entre ukrainien, anglais et fran√ßais\n‚Ä¢ Annuler/Refaire : Ctrl+Z / Ctrl+Y pour l'historique des actions\n\nüí° Commencez par ajouter des sommets au canevas !",
    "ok_button": "OK"
  },
  "theme_select_dialog": {
    "window_title": "S√©lection de Th√®me",
    "style_label": "S√©lectionner le style de th√®me :",
    "color_label": "S√©lectionner la couleur de th√®me :",
    "modern": "Moderne",
    "classic": "Classique",
    "dark": "Sombre",
    "light": "Clair",
    "green": "Vert",
    "blue": "Bleu",
    "red": "Rouge",
    "yellow": "Jaune",
    "ok_button": "OK"
  },
  "vertex_edit_dialog": {
    "window_title": "Modifier le Sommet",
    "vertex_name_label": "Nom du sommet :",
    "additional_data_label": "Donn√©es suppl√©mentaires du sommet (cl√©-valeur) :",
    "key_label": "Cl√© :",
    "value_label": "Valeur :",
    "ok_button": "OK",
    "cancel_button": "Annuler",
    "vertex_data_info": "Donn√©es du sommet{node_info} apr√®s modification : {data}"
  },
  "common_dialogs": {
    "ok_text": "ok",
    "select_text": "s√©lectionner"
  },
  "graph_analysis_tab": {
    "title": "<h2>Analyse de Graphe</h2>",
    "traversal_option": "Parcours de graphe (BFS/DFS)",
    "spanning_tree_option": "Arbres couvrants (Prim/Kruskal)",
    "flow_algorithms_option": "Algorithmes de flux (Ford-Fulkerson/Coupe-Min)",
    "shortest_paths_option": "Chemins les plus courts (Dijkstra/Bellman-Ford/Floyd-Warshall)",
    "special_paths_option": "Chemins sp√©ciaux (simple/plus long/hamiltonien/eul√©rien)"
  },
  "graph_tabs_widget": {
    "graph_info_tab": "Graphe et Informations",
    "matrices_tab": "Matrices",
    "analysis_tab": "Analyse de Graphe",
    "traversal_tab": "Parcours de Graphe"
  },
  "matrix_tabs_widget": {
    "adjacency_matrix_title": "Matrice d'Adjacence",
    "incidence_matrix_title": "Matrice d'Incidence",
    "adjacency_tab": "Adjacence",
    "incidence_tab": "Incidence",
    "edge_label": "E{index}"
  },
  "traversal_tab": {
    "empty_graph": "Le graphe est vide",
    "select_start_vertex": "S√©lectionner le sommet de d√©part",
    "no_reachable_vertices": "Aucun sommet accessible trouv√©.",
    "no_components_found": "Aucune composante connexe trouv√©e.",
    "components_found": "Trouv√© {count} composante(s) connexe(s) : {components}",
    "no_cycles_found": "Aucun cycle trouv√©.",
    "cycles_found": "Trouv√© {count} cycle(s) : {cycles}",
    "select_algorithm": "S√©lectionner l'algorithme de parcours.",
    "stopped": "Arr√™t√©",
    "traversal_order": "Ordre de parcours : {node}",
    "result_vertices": "Sommets r√©sultats : {vertices}",
    "component_result": "Composante {index} : {vertices}",
    "cycle_result": "Cycle {index} : {vertices}",
    "traversal_completed": "Parcours termin√©"
  },
  "theme_manager": {
    "theme_change_info": "Changement de th√®me vers : {theme_name}",
    "theme_save_error": "√âchec de la sauvegarde du th√®me : {error}"
  },
  "analysis_output_controls": {
    "export_txt_button": "Exporter vers .txt",
    "clear_results_button": "Effacer les r√©sultats",
    "save_dialog_title": "Sauvegarder comme .txt"
  },
  "flow_algorithms_widget": {
    "source_label": "ID Source :",
    "sink_label": "ID Puits :",
    "ford_fulkerson_button": "Ford-Fulkerson (flux max)",
    "min_cut_button": "Coupe-Min",
    "error_title": "Erreur",
    "select_source_sink": "S√©lectionner les IDs source et puits.",
    "max_flow_result": "Flux maximum : {flow}",
    "min_cut_result": "Coupe minimale : {cut}\nAr√™tes de coupe :\n{edges}",
    "error_result": "Erreur : {error}"
  },
  "shortest_paths_widget": {
    "start_vertex_label": "ID Sommet de d√©part :",
    "end_vertex_label": "ID Sommet d'arriv√©e :",
    "dijkstra_all_button": "Dijkstra (source unique vers tous)",
    "bellman_all_button": "Bellman-Ford (source unique vers tous)",
    "floyd_all_button": "Floyd-Warshall (tous vers tous)",
    "dijkstra_path_button": "Dijkstra (chemin entre deux)",
    "bellman_path_button": "Bellman-Ford (chemin entre deux)",
    "floyd_path_button": "Floyd-Warshall (chemin entre deux)",
    "floyd_all_paths_button": "Floyd-Warshall (tous les chemins les plus courts)",
    "error_title": "Erreur",
    "select_start_vertex": "S√©lectionner le sommet de d√©part.",
    "select_start_end_vertices": "S√©lectionner les sommets de d√©part et d'arriv√©e.",
    "dijkstra_distances": "Distances les plus courtes (Dijkstra) :",
    "bellman_distances": "Distances les plus courtes (Bellman-Ford) :",
    "floyd_matrix": "Matrice des distances les plus courtes (Floyd-Warshall) :",
    "floyd_all_paths": "Tous les chemins les plus courts (Floyd-Warshall) :",
    "dijkstra_path": "Chemin (Dijkstra) : {path}\nLongueur : {length}",
    "bellman_path": "Chemin (Bellman-Ford) : {path}\nLongueur : {length}",
    "floyd_path": "Chemin (Floyd-Warshall) : {path}\nLongueur : {length}",
    "path_not_found": "Chemin non trouv√©.",
    "path_not_exists": "{from} -> {to} : le chemin n'existe pas",
    "path_result": "{from} -> {to} : {path} (longueur {length})",
    "vertex_not_found": "Erreur : le sommet s√©lectionn√© n'est pas pr√©sent dans le graphe.",
    "error_result": "Erreur : {error}"
  },
  "spanning_tree_widget": {
    "prim_button": "Arbre couvrant (Prim)",
    "kruskal_button": "Arbre couvrant (Kruskal)",
    "prim_result": "Arbre couvrant (Prim) :\n{edges}\nPoids total : {weight}",
    "kruskal_result": "Arbre couvrant (Kruskal) :\n{edges}\nPoids total : {weight}",
    "no_spanning_tree": "Arbre couvrant non trouv√© (graphe non connexe ou incorrect).",
    "error_result": "Erreur : {error}"
  },
  "special_paths_widget": {
    "start_vertex_label": "ID Sommet de d√©part :",
    "end_vertex_label": "ID Sommet d'arriv√©e :",
    "simple_path_button": "Chemin simple (DFS)",
    "longest_path_button": "Chemin simple le plus long",
    "hamiltonian_path_button": "Chemin hamiltonien",
    "eulerian_path_button": "Chemin eul√©rien",
    "error_title": "Erreur",
    "select_start_end_vertices": "S√©lectionner les sommets de d√©part et d'arriv√©e.",
    "simple_path_result": "Chemin simple : {path}",
    "longest_path_result": "Chemin simple le plus long : {path} (longueur {length})",
    "hamiltonian_path_result": "Chemin hamiltonien : {path}",
    "eulerian_path_result": "Chemin eul√©rien : {path}",
    "path_not_found": "Chemin non trouv√©.",
    "eulerian_path_not_found": "Chemin eul√©rien non trouv√©.",
    "error_result": "Erreur : {error}"
  },
  "traversal_widget": {
    "start_vertex_label": "ID Sommet de d√©part :",
    "bfs_button": "Parcours en largeur (BFS)",
    "dfs_button": "Parcours en profondeur (DFS)",
    "error_title": "Erreur",
    "select_start_vertex": "S√©lectionner le sommet de d√©part.",
    "bfs_result": "Ordre de parcours BFS : {order}",
    "dfs_result": "Ordre de parcours DFS : {order}",
    "error_result": "Erreur : {error}"
  },
  "graph_canvas_widget": {
    "open_graph_dialog_title": "Ouvrir graphe depuis .json"
  },
  "graph_import_export_widget": {
    "export_json_button": "Exporter vers .json",
    "import_json_button": "Importer depuis .json",
    "save_graph_dialog_title": "Sauvegarder graphe comme .json",
    "open_graph_dialog_title": "Ouvrir graphe depuis .json"
  },
  "graph_info_export_widget": {
    "export_txt_button": "Exporter vers .txt",
    "save_txt_dialog_title": "Sauvegarder comme .txt"
  },
  "adjacency_matrix_export_widget": {
    "export_csv_button": "Exporter vers CSV",
    "export_png_button": "Exporter vers PNG",
    "error_title": "Erreur",
    "success_title": "Succ√®s",
    "empty_matrix_error": "La matrice est vide ou incorrecte !",
    "save_csv_dialog_title": "Sauvegarder comme CSV",
    "adjacency_matrix_saved": "Matrice d'adjacence sauvegard√©e en CSV !"
  },
  "incidence_matrix_export_widget": {
    "export_csv_button": "Exporter vers CSV",
    "export_png_button": "Exporter vers PNG",
    "error_title": "Erreur",
    "success_title": "Succ√®s",
    "empty_matrix_error": "La matrice est vide ou incorrecte !",
    "save_csv_dialog_title": "Sauvegarder comme CSV",
    "incidence_matrix_saved": "Matrice d'incidence sauvegard√©e en CSV !"
  },
  "traversal_control_widget": {
    "method_label": "M√©thode :",
    "start_vertex_label": "Sommet de d√©part :",
    "start_button": "D√©marrer",
    "stop_button": "Arr√™ter",
    "bfs_method": "Parcours en largeur (BFS)",
    "dfs_method": "Parcours en profondeur (DFS)",
    "dijkstra_method": "Dijkstra",
    "connected_components_method": "Composantes connexes",
    "cycle_detection_method": "D√©tection de cycle"
  },
  "graph_settings_widget": {
    "select_graph": "S√©lectionner graphe",
    "graph_directed": "Graphe orient√©",
    "graph_weighted": "Graphe pond√©r√©",
    "auto_name_vertices": "Nommage automatique des sommets",
    "select_theme": "S√©lectionner th√®me",
    "select_language": "Langue",
    "instruction": "Instructions"
  },
  "language_select_dialog": {
    "title": "S√©lection de Langue",
    "select_language_label": "S√©lectionner la langue :",
    "ukrainian_language": "–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞",
    "english_language": "English",
    "french_language": "Fran√ßais",
    "ok_button": "OK",
    "cancel_button": "Annuler"
  },
  "splash": {
    "splash_initializing": "Initialisation...",
    "splash_loading_locale": "Chargement de la localisation...",
    "splash_loading_components": "Chargement des composants...",
    "splash_loading_algorithms": "Chargement des algorithmes...",
    "splash_loading_interface": "Chargement de l'interface...",
    "splash_loading_themes": "Chargement des th√®mes...",
    "splash_loading_complete": "Chargement termin√© !",
    "app_title": "GAP - Graph Analyzer Project",
    "app_description": "Analyseur de graphes avanc√© avec visualisation"
  }
}
