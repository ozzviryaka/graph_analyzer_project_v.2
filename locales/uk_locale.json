{
  "main": {
    "app_start": "Запуск програми",
    "app_end": "Завершення роботи програми"
  },
  "ford_fulkerson": {
    "directed_error": "Алгоритм Форда-Фалкерсона працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Форда-Фалкерсона.",
    "init_info": "Ініціалізація FordFulkerson: граф орієнтований, всі ваги ребер коректні.",
    "max_flow_log_info": "Максимальний потік між {source_id} та {sink_id}: {max_flow}"
  },
  "min_cut": {
    "directed_error": "Алгоритм мінімального розрізу працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму мінімального розрізу.",
    "init_info": "Ініціалізація MinCut: граф орієнтований, всі ваги ребер коректні.",
    "min_cut_start": "Пошук мінімального розрізу між {source_id} та {sink_id} розпочато.",
    "min_cut_found_path": "Знайдено шлях з потоком {path_flow}. Поточний max_flow: {max_flow}",
    "min_cut_end": "Мінімальний розріз: {max_flow}, кількість ребер у розрізі: {len_cut_edges}"
  },
  "bellman_ford": {
    "weight_error": "Усі ребра повинні мати вагу для алгоритму Беллмана-Форда.",
    "init_info": "Ініціалізація BellmanFord: всі ваги ребер коректні.",
    "bellman_ford_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v}: відстань {d}, попередник {u}",
    "enable_negative_cycles": "Граф містить від’ємний цикл.",
    "bellman_ford_end": "Пошук найкоротших шляхів завершено."
  },
  "dijkstra": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Дейкстри.",
    "init_info": "Ініціалізація Dijkstra: всі ваги ребер коректні.",
    "dijkstra_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v_id}: відстань {alt}, попередник {u_id}",
    "dijkstra_end": "Пошук найкоротших шляхів завершено."
  },
  "floyd_warshall": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Флойда-Уоршелла.",
    "init_info": "Ініціалізація FloydWarshall: всі ваги ребер коректні.",
    "floyd_warshall_start": "Початок виконання алгоритму Флойда-Уоршелла.",
    "update_path": "Оновлено шлях {from_node} → {to_node} через {via_node}: відстань {distance}",
    "floyd_warshall_end": "Алгоритм Флойда-Уоршелла завершено."
  },
  "kruskal": {
    "directed_error": "Алгоритм Краскала працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Краскала.",
    "init_info": "Ініціалізація Kruskal: граф неспрямований, всі ваги ребер коректні.",
    "kruskal_start": "Пошук мінімального остовного дерева розпочато.",
    "update_path": "Додано ребро ({u}, {v}) з вагою {edge_weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "kruskal_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  },
  "prim": {
    "directed_error": "Алгоритм Прима працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Прима.",
    "init_info": "Ініціалізація Prim: граф неспрямований, всі ваги ребер коректні.",
    "prim_start": "Пошук мінімального остовного дерева (MST) розпочато.",
    "update_path": "Додано ребро ({edge_source_id}, {edge_target_id}) з вагою {weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "prim_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  },
  "eulerian_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "components_error": "Граф повинен містити хоча б одну вершину та ребро.",
    "init_info": "Ініціалізація EulerianPathFinder: граф коректний.",
    "eulerian_start": "Пошук ейлерового шляху розпочато.",
    "enable_eulerian_warn": "Ейлерового шляху у графі не існує.",
    "enable_eulerian_not_all_edges_used_warn": "Не всі ребра використані — ейлерового шляху не існує.",
    "eulerian_end": "Знайдено ейлерів шлях: {path_str}"
  },
  "hamiltonian_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація HamiltonianPathFinder: граф коректний.",
    "hamiltonian_start": "Пошук гамільтонового шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "hamiltonian_end": "Знайдено гамільтонів шлях: {path_str}",
    "enable_path_warn": "Гамільтонового шляху між {start_id} та {end_id} не існує."
  },
  "longest_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація LongestPathFinder: граф коректний.",
    "longest_start": "Пошук найдовшого простого шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "longest_end": "Знайдено найдовший простий шлях: {path_str} (довжина {len_longest_path})",
    "enable_path_warn": "Найдовшого простого шляху між {start_id} та {end_id} не існує."
  },
  "simple_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація SimplePathFinder: граф коректний.",
    "simple_start": "Пошук простого шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "simple_end": "Знайдено простий шлях: {path_str}",
    "enable_path_warn": "Простого шляху між {start_id} та {end_id} не існує."
  }
}