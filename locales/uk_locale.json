{
  "main": {
    "app_start": "Запуск програми",
    "app_end": "Завершення роботи програми"
  },
  "ford_fulkerson": {
    "directed_error": "Алгоритм Форда-Фалкерсона працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Форда-Фалкерсона.",
    "init_info": "Ініціалізація FordFulkerson: граф орієнтований, всі ваги ребер коректні.",
    "max_flow_log_info": "Максимальний потік між {source_id} та {sink_id}: {max_flow}"
  },
  "min_cut": {
    "directed_error": "Алгоритм мінімального розрізу працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму мінімального розрізу.",
    "init_info": "Ініціалізація MinCut: граф орієнтований, всі ваги ребер коректні.",
    "min_cut_start": "Пошук мінімального розрізу між {source_id} та {sink_id} розпочато.",
    "min_cut_found_path": "Знайдено шлях з потоком {path_flow}. Поточний max_flow: {max_flow}",
    "min_cut_end": "Мінімальний розріз: {max_flow}, кількість ребер у розрізі: {len_cut_edges}"
  },
  "bellman_ford": {
    "weight_error": "Усі ребра повинні мати вагу для алгоритму Беллмана-Форда.",
    "init_info": "Ініціалізація BellmanFord: всі ваги ребер коректні.",
    "bellman_ford_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v}: відстань {d}, попередник {u}",
    "enable_negative_cycles": "Граф містить від’ємний цикл.",
    "bellman_ford_end": "Пошук найкоротших шляхів завершено."
  },
  "dijkstra": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Дейкстри.",
    "init_info": "Ініціалізація Dijkstra: всі ваги ребер коректні.",
    "dijkstra_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v_id}: відстань {alt}, попередник {u_id}",
    "dijkstra_end": "Пошук найкоротших шляхів завершено."
  },
  "floyd_warshall": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Флойда-Уоршелла.",
    "init_info": "Ініціалізація FloydWarshall: всі ваги ребер коректні.",
    "floyd_warshall_start": "Початок виконання алгоритму Флойда-Уоршелла.",
    "update_path": "Оновлено шлях {from_node} → {to_node} через {via_node}: відстань {distance}",
    "floyd_warshall_end": "Алгоритм Флойда-Уоршелла завершено."
  },
  "kruskal": {
    "directed_error": "Алгоритм Краскала працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Краскала.",
    "init_info": "Ініціалізація Kruskal: граф неспрямований, всі ваги ребер коректні.",
    "kruskal_start": "Пошук мінімального остовного дерева розпочато.",
    "update_path": "Додано ребро ({u}, {v}) з вагою {edge_weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "kruskal_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  },
  "prim": {
    "directed_error": "Алгоритм Прима працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Прима.",
    "init_info": "Ініціалізація Prim: граф неспрямований, всі ваги ребер коректні.",
    "prim_start": "Пошук мінімального остовного дерева (MST) розпочато.",
    "update_path": "Додано ребро ({edge_source_id}, {edge_target_id}) з вагою {weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "prim_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  }
}