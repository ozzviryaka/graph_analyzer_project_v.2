{
  "main": {
    "app_start": "======================================Запуск програми======================================\n\n",
    "app_end": "=================================Завершення роботи програми================================\n\n"
  },
  "ford_fulkerson": {
    "directed_error": "Алгоритм Форда-Фалкерсона працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Форда-Фалкерсона.",
    "init_info": "Ініціалізація FordFulkerson: граф орієнтований, всі ваги ребер коректні.",
    "max_flow_log_info": "Максимальний потік між {source_id} та {sink_id}: {max_flow}"
  },
  "min_cut": {
    "directed_error": "Алгоритм мінімального розрізу працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму мінімального розрізу.",
    "init_info": "Ініціалізація MinCut: граф орієнтований, всі ваги ребер коректні.",
    "min_cut_start": "Пошук мінімального розрізу між {source_id} та {sink_id} розпочато.",
    "min_cut_found_path": "Знайдено шлях з потоком {path_flow}. Поточний max_flow: {max_flow}",
    "min_cut_end": "Мінімальний розріз: {max_flow}, кількість ребер у розрізі: {len_cut_edges}"
  },
  "bellman_ford": {
    "weight_error": "Усі ребра повинні мати вагу для алгоритму Беллмана-Форда.",
    "init_info": "Ініціалізація BellmanFord: всі ваги ребер коректні.",
    "bellman_ford_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v}: відстань {d}, попередник {u}",
    "enable_negative_cycles": "Граф містить від’ємний цикл.",
    "bellman_ford_end": "Пошук найкоротших шляхів завершено."
  },
  "dijkstra": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Дейкстри.",
    "init_info": "Ініціалізація Dijkstra: всі ваги ребер коректні.",
    "dijkstra_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v_id}: відстань {alt}, попередник {u_id}",
    "dijkstra_end": "Пошук найкоротших шляхів завершено."
  },
  "floyd_warshall": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Флойда-Уоршелла.",
    "init_info": "Ініціалізація FloydWarshall: всі ваги ребер коректні.",
    "floyd_warshall_start": "Початок виконання алгоритму Флойда-Уоршелла.",
    "update_path": "Оновлено шлях {from_node} → {to_node} через {via_node}: відстань {distance}",
    "floyd_warshall_end": "Алгоритм Флойда-Уоршелла завершено."
  },
  "kruskal": {
    "directed_error": "Алгоритм Краскала працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Краскала.",
    "init_info": "Ініціалізація Kruskal: граф неспрямований, всі ваги ребер коректні.",
    "kruskal_start": "Пошук мінімального остовного дерева розпочато.",
    "update_path": "Додано ребро ({u}, {v}) з вагою {edge_weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "kruskal_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  },
  "prim": {
    "directed_error": "Алгоритм Прима працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Прима.",
    "init_info": "Ініціалізація Prim: граф неспрямований, всі ваги ребер коректні.",
    "prim_start": "Пошук мінімального остовного дерева (MST) розпочато.",
    "update_path": "Додано ребро ({edge_source_id}, {edge_target_id}) з вагою {weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "prim_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  },
  "eulerian_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "components_error": "Граф повинен містити хоча б одну вершину та ребро.",
    "init_info": "Ініціалізація EulerianPathFinder: граф коректний.",
    "eulerian_start": "Пошук ейлерового шляху розпочато.",
    "enable_eulerian_warn": "Ейлерового шляху у графі не існує.",
    "enable_eulerian_not_all_edges_used_warn": "Не всі ребра використані — ейлерового шляху не існує.",
    "eulerian_end": "Знайдено ейлерів шлях: {path_str}"
  },
  "hamiltonian_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація HamiltonianPathFinder: граф коректний.",
    "hamiltonian_start": "Пошук гамільтонового шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "hamiltonian_end": "Знайдено гамільтонів шлях: {path_str}",
    "enable_path_warn": "Гамільтонового шляху між {start_id} та {end_id} не існує."
  },
  "longest_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація LongestPathFinder: граф коректний.",
    "longest_start": "Пошук найдовшого простого шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "longest_end": "Знайдено найдовший простий шлях: {path_str} (довжина {len_longest_path})",
    "enable_path_warn": "Найдовшого простого шляху між {start_id} та {end_id} не існує."
  },
  "simple_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація SimplePathFinder: граф коректний.",
    "simple_start": "Пошук простого шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "simple_end": "Знайдено простий шлях: {path_str}",
    "enable_path_warn": "Простого шляху між {start_id} та {end_id} не існує."
  },
  "bfs": {
    "methods_error": "Граф повинен мати методи nodes та neighbors.",
    "nodes_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація BFS: граф коректний.",
    "bfs_start": "Початок BFS з вершини {start_id}.",
    "start_error": "Початкова вершина відсутня у графі.",
    "bfs_end": "BFS завершено. Порядок обходу: {path_str}"
  },
  "dfs": {
    "methods_error": "Граф повинен мати методи nodes та neighbors.",
    "nodes_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація DFS: граф коректний.",
    "dfs_start": "Початок DFS з вершини {start_id}.",
    "start_error": "Початкова вершина відсутня у графі.",
    "dfs_end": "DFS завершено. Порядок обходу: {path_str}"
  },
  "traversal_algorithms": {
    "bfs_start": "BFS стартує з вершини {start_id}",
    "bfs_update": "BFS відвідав вершину {node_id}",
    "bfs_end": "BFS завершено. Порядок: {order}",
    "dfs_start": "DFS стартує з вершини {start_id}",
    "dfs_update": "DFS відвідав вершину {node_id}",
    "dfs_end": "DFS завершено. Порядок: {order}",
    "dijkstra_start": "Dijkstra стартує з вершини {start_id}",
    "dijkstra_update": "Dijkstra відвідав вершину {node_id} (відстань {dist})",
    "dijkstra_end": "Dijkstra завершено. Порядок: {order}",
    "comp_start": "Пошук компонентів зв'язності стартує",
    "comp_update": "Знайдено компоненту: {comp}",
    "comp_end": "Пошук компонент завершено. Всього компонент: {len_components}",
    "cycle_start": "Пошук циклів стартує",
    "cycle_update": "Знайдено цикл: {cycle}",
    "cycle_end": "Пошук циклів завершено. Порядок: {order}, Кількість циклів: {len_cycles}"
  },
  "graph_info": {
    "num_nodes": "Кількість вершин",
    "num_edges": "Кількість ребер",
    "min_degree": "Мінімальний ступінь",
    "max_degree": "Максимальний ступінь",
    "avg_degree": "Середній ступінь",
    "is_connected": "Зв'язний граф",
    "structural_redundancy": "Структурна надмірність",
    "degree_inequality": "Нерівномірність розподілу зв'язків",
    "structural_compactness": "Структурна компактність",
    "relative_compactness": "Відносний показник компактності",
    "degree_centralization": "Ступінь централізації",
    "yes": "Так",
    "no": "Ні"
  },
  "edge_converter": {
    "not_directed_error": "Передане ребро не є спрямованим.",
    "directed_to_undirected_info": "Конвертовано спрямоване ребро ({source_id} -> {target_id}) у неспрямоване.",
    "not_undirected_error": "Передане ребро не є неспрямованим.",
    "undirected_to_directed_info": "Конвертовано неспрямоване ребро ({source_id} -- {target_id}) у спрямоване ({new_source_id} -> {new_target_id})."
  },
  "graph_converter": {
    "directed_to_undirected_info": "Спрямований граф конвертовано у неспрямований.",
    "undirected_to_directed_info": "Неспрямований граф конвертовано у спрямований."
  },
  "base_edge": {
    "repr_format": "{class_name}(джерело={source}, призначення={target}, дані={data})"
  },
  "node": {
    "created_info": "Створено вузол: id={node_id}, дані={data}, позиція={pos}",
    "repr_format": "Вузол(id={node_id}, дані={data}, позиція={pos})"
  },
  "directed_edge": {
    "created_info": "Створено спрямоване ребро: джерело={source_id}, призначення={target_id}, вага={weight}, дані={data}"
  },
  "undirected_edge": {
    "created_info": "Створено неспрямоване ребро: вузол1={node1_id}, вузол2={node2_id}, вага={weight}, дані={data}"
  },
  "directed_graph": {
    "nodes_not_in_graph_error": "Обидва вузли ребра мають бути додані до графа перед додаванням ребра."
  },
  "undirected_graph": {
    "nodes_not_in_graph_error": "Обидва вузли ребра мають бути додані до графа перед додаванням ребра."
  },
  "graph_loader": {
    "success_load": "Граф успішно завантажено з файлу {filepath}",
    "error_load": "Помилка при завантаженні графа: {error}"
  },
  "graph_saver": {
    "success_save": "Граф успішно збережено у файл {filepath}",
    "error_save": "Помилка при збереженні графа: {error}"
  },
  "session_exporter": {
    "export_start": "Початок експорту сесії у файл: {filepath}",
    "export_success": "Сесію успішно експортовано у файл: {filepath}",
    "export_error": "Помилка при експорті сесії: {error}"
  },
  "session_importer": {
    "import_start": "Початок імпорту сесії з файлу: {filepath}",
    "class_not_found_warning": "Клас графа {class_name} не знайдено у graph_class_map",
    "edge_nodes_not_found_warning": "Не знайдено вузли для ребра: {edge_info}",
    "import_success": "Сесію успішно імпортовано з файлу: {filepath}",
    "import_error": "Помилка при імпорті сесії: {error}"
  }
}