{
  "main": {
    "app_start": "======================================Запуск програми======================================\n\n",
    "app_end": "=================================Завершення роботи програми================================\n\n"
  },
  "ford_fulkerson": {
    "directed_error": "Алгоритм Форда-Фалкерсона працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Форда-Фалкерсона.",
    "init_info": "Ініціалізація FordFulkerson: граф орієнтований, всі ваги ребер коректні.",
    "max_flow_log_info": "Максимальний потік між {source_id} та {sink_id}: {max_flow}"
  },
  "min_cut": {
    "directed_error": "Алгоритм мінімального розрізу працює лише для орієнтованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму мінімального розрізу.",
    "init_info": "Ініціалізація MinCut: граф орієнтований, всі ваги ребер коректні.",
    "min_cut_start": "Пошук мінімального розрізу між {source_id} та {sink_id} розпочато.",
    "min_cut_found_path": "Знайдено шлях з потоком {path_flow}. Поточний max_flow: {max_flow}",
    "min_cut_end": "Мінімальний розріз: {max_flow}, кількість ребер у розрізі: {len_cut_edges}"
  },
  "bellman_ford": {
    "weight_error": "Усі ребра повинні мати вагу для алгоритму Беллмана-Форда.",
    "init_info": "Ініціалізація BellmanFord: всі ваги ребер коректні.",
    "bellman_ford_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v}: відстань {d}, попередник {u}",
    "enable_negative_cycles": "Граф містить від’ємний цикл.",
    "bellman_ford_end": "Пошук найкоротших шляхів завершено."
  },
  "dijkstra": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Дейкстри.",
    "init_info": "Ініціалізація Dijkstra: всі ваги ребер коректні.",
    "dijkstra_start": "Пошук найкоротших шляхів від вершини {start_id} розпочато.",
    "update_path": "Оновлено шлях до {v_id}: відстань {alt}, попередник {u_id}",
    "dijkstra_end": "Пошук найкоротших шляхів завершено."
  },
  "floyd_warshall": {
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Флойда-Уоршелла.",
    "init_info": "Ініціалізація FloydWarshall: всі ваги ребер коректні.",
    "floyd_warshall_start": "Початок виконання алгоритму Флойда-Уоршелла.",
    "update_path": "Оновлено шлях {from_node} → {to_node} через {via_node}: відстань {distance}",
    "floyd_warshall_end": "Алгоритм Флойда-Уоршелла завершено."
  },
  "kruskal": {
    "directed_error": "Алгоритм Краскала працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Краскала.",
    "init_info": "Ініціалізація Kruskal: граф неспрямований, всі ваги ребер коректні.",
    "kruskal_start": "Пошук мінімального остовного дерева розпочато.",
    "update_path": "Додано ребро ({u}, {v}) з вагою {edge_weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "kruskal_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  },
  "prim": {
    "directed_error": "Алгоритм Прима працює лише для неспрямованих графів.",
    "weight_error": "Усі ребра повинні мати невід'ємні ваги для алгоритму Прима.",
    "init_info": "Ініціалізація Prim: граф неспрямований, всі ваги ребер коректні.",
    "prim_start": "Пошук мінімального остовного дерева (MST) розпочато.",
    "update_path": "Додано ребро ({edge_source_id}, {edge_target_id}) з вагою {weight} до MST.",
    "connected_warn": "Граф не є зв'язним — MST не існує для всіх вершин.",
    "prim_end": "Завершено. MST вага: {total_weight}, кількість ребер: {len_mst_edges}"
  },
  "eulerian_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "components_error": "Граф повинен містити хоча б одну вершину та ребро.",
    "init_info": "Ініціалізація EulerianPathFinder: граф коректний.",
    "eulerian_start": "Пошук ейлерового шляху розпочато.",
    "enable_eulerian_warn": "Ейлерового шляху у графі не існує.",
    "enable_eulerian_not_all_edges_used_warn": "Не всі ребра використані — ейлерового шляху не існує.",
    "eulerian_end": "Знайдено ейлерів шлях: {path_str}"
  },
  "hamiltonian_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація HamiltonianPathFinder: граф коректний.",
    "hamiltonian_start": "Пошук гамільтонового шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "hamiltonian_end": "Знайдено гамільтонів шлях: {path_str}",
    "enable_path_warn": "Гамільтонового шляху між {start_id} та {end_id} не існує."
  },
  "longest_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація LongestPathFinder: граф коректний.",
    "longest_start": "Пошук найдовшого простого шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "longest_end": "Знайдено найдовший простий шлях: {path_str} (довжина {len_longest_path})",
    "enable_path_warn": "Найдовшого простого шляху між {start_id} та {end_id} не існує."
  },
  "simple_path_finder": {
    "methods_error": "Граф повинен мати методи nodes, edges та neighbors.",
    "enable_node_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація SimplePathFinder: граф коректний.",
    "simple_start": "Пошук простого шляху між {start_id} та {end_id} розпочато.",
    "start_end_error": "Початкова або кінцева вершина відсутня у графі.",
    "simple_end": "Знайдено простий шлях: {path_str}",
    "enable_path_warn": "Простого шляху між {start_id} та {end_id} не існує."
  },
  "bfs": {
    "methods_error": "Граф повинен мати методи nodes та neighbors.",
    "nodes_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація BFS: граф коректний.",
    "bfs_start": "Початок BFS з вершини {start_id}.",
    "start_error": "Початкова вершина відсутня у графі.",
    "bfs_end": "BFS завершено. Порядок обходу: {path_str}"
  },
  "dfs": {
    "methods_error": "Граф повинен мати методи nodes та neighbors.",
    "nodes_error": "Граф не містить жодної вершини.",
    "init_info": "Ініціалізація DFS: граф коректний.",
    "dfs_start": "Початок DFS з вершини {start_id}.",
    "start_error": "Початкова вершина відсутня у графі.",
    "dfs_end": "DFS завершено. Порядок обходу: {path_str}"
  },
  "traversal_algorithms": {
    "bfs_start": "BFS стартує з вершини {start_id}",
    "bfs_update": "BFS відвідав вершину {node_id}",
    "bfs_end": "BFS завершено. Порядок: {order}",
    "dfs_start": "DFS стартує з вершини {start_id}",
    "dfs_update": "DFS відвідав вершину {node_id}",
    "dfs_end": "DFS завершено. Порядок: {order}",
    "dijkstra_start": "Dijkstra стартує з вершини {start_id}",
    "dijkstra_update": "Dijkstra відвідав вершину {node_id} (відстань {dist})",
    "dijkstra_end": "Dijkstra завершено. Порядок: {order}",
    "comp_start": "Пошук компонентів зв'язності стартує",
    "comp_update": "Знайдено компоненту: {comp}",
    "comp_end": "Пошук компонент завершено. Всього компонент: {len_components}",
    "cycle_start": "Пошук циклів стартує",
    "cycle_update": "Знайдено цикл: {cycle}",
    "cycle_end": "Пошук циклів завершено. Порядок: {order}, Кількість циклів: {len_cycles}"
  },
  "graph_info": {
    "num_nodes": "Кількість вершин",
    "num_edges": "Кількість ребер",
    "min_degree": "Мінімальний ступінь",
    "max_degree": "Максимальний ступінь",
    "avg_degree": "Середній ступінь",
    "is_connected": "Зв'язний граф",
    "structural_redundancy": "Структурна надмірність",
    "degree_inequality": "Нерівномірність розподілу зв'язків",
    "structural_compactness": "Структурна компактність",
    "relative_compactness": "Відносний показник компактності",
    "degree_centralization": "Ступінь централізації",
    "yes": "Так",
    "no": "Ні"
  },
  "edge_converter": {
    "not_directed_error": "Передане ребро не є спрямованим.",
    "directed_to_undirected_info": "Конвертовано спрямоване ребро ({source_id} -> {target_id}) у неспрямоване.",
    "not_undirected_error": "Передане ребро не є неспрямованим.",
    "undirected_to_directed_info": "Конвертовано неспрямоване ребро ({source_id} -- {target_id}) у спрямоване ({new_source_id} -> {new_target_id})."
  },
  "graph_converter": {
    "directed_to_undirected_info": "Спрямований граф конвертовано у неспрямований.",
    "undirected_to_directed_info": "Неспрямований граф конвертовано у спрямований."
  },
  "base_edge": {
    "repr_format": "{class_name}(джерело={source}, призначення={target}, дані={data})"
  },
  "node": {
    "created_info": "Створено вузол: id={node_id}, дані={data}, позиція={pos}",
    "repr_format": "Вузол(id={node_id}, дані={data}, позиція={pos})"
  },
  "directed_edge": {
    "created_info": "Створено спрямоване ребро: джерело={source_id}, призначення={target_id}, вага={weight}, дані={data}"
  },
  "undirected_edge": {
    "created_info": "Створено неспрямоване ребро: вузол1={node1_id}, вузол2={node2_id}, вага={weight}, дані={data}"
  },
  "directed_graph": {
    "nodes_not_in_graph_error": "Обидва вузли ребра мають бути додані до графа перед додаванням ребра."
  },
  "undirected_graph": {
    "nodes_not_in_graph_error": "Обидва вузли ребра мають бути додані до графа перед додаванням ребра."
  },
  "graph_loader": {
    "success_load": "Граф успішно завантажено з файлу {filepath}",
    "error_load": "Помилка при завантаженні графа: {error}"
  },
  "graph_saver": {
    "success_save": "Граф успішно збережено у файл {filepath}",
    "error_save": "Помилка при збереженні графа: {error}"
  },
  "session_exporter": {
    "export_start": "Початок експорту сесії у файл: {filepath}",
    "export_success": "Сесію успішно експортовано у файл: {filepath}",
    "export_error": "Помилка при експорті сесії: {error}"
  },
  "session_importer": {
    "import_start": "Початок імпорту сесії з файлу: {filepath}",
    "class_not_found_warning": "Клас графа {class_name} не знайдено у graph_class_map",
    "edge_nodes_not_found_warning": "Не знайдено вузли для ребра: {edge_info}",
    "import_success": "Сесію успішно імпортовано з файлу: {filepath}",
    "import_error": "Помилка при імпорті сесії: {error}"
  },
  "graph_canvas": {
    "undo_tooltip": "Скасувати останню дію (Undo, Ctrl+Z)",
    "redo_tooltip": "Повернути дію (Redo, Ctrl+Y)"
  },
  "edge_edit_dialog": {
    "window_title": "Додавання/Редагування ребра",
    "weight_label": "Вага ребра:",
    "additional_data_label": "Додаткові дані (ключ-значення):",
    "key_label": "Ключ:",
    "value_label": "Значення:",
    "ok_button": "OK",
    "cancel_button": "Скасувати"
  },
  "graph_select_dialog": {
    "window_title": "Вибір графа",
    "select_graph_label": "Оберіть граф для роботи:",
    "new_graph_button": "Новий граф",
    "delete_graph_button": "Видалити граф",
    "select_button": "Вибрати",
    "export_session_button": "Експорт сесії",
    "import_session_button": "Імпорт сесії",
    "directed": "Орієнтований",
    "undirected": "Неорієнтований",
    "weighted": "Ваговий",
    "unweighted": "Неваговий",
    "graph_type_title": "Тип графа",
    "graph_type_label": "Оберіть тип графа:",
    "weight_title": "Ваговість",
    "weight_label": "Граф ваговий?",
    "auto_name_title": "Автоматична назва вершин",
    "auto_name_label": "Використовувати автоназви для вершин?",
    "graph_name_title": "Назва графа",
    "graph_name_label": "Введіть назву графа:",
    "yes": "Так",
    "no": "Ні",
    "delete_warning_title": "Видалення",
    "delete_active_graph": "Неможливо видалити активний граф. Спочатку виберіть інший.",
    "delete_no_selection": "Оберіть граф для видалення.",
    "select_warning_title": "Вибір",
    "select_no_selection": "Оберіть граф зі списку.",
    "export_session_title": "Експортувати сесію",
    "import_session_title": "Імпортувати сесію",
    "session_files": "Session Files (*.json)"
  },
  "instruction_dialog": {
    "window_title": "Інструкція",
    "instruction_text": "\u2139  Інструкція: створення та редагування графа\n\n--- ОСНОВНІ ДІЇ ---\n- Додати вершину: ЛКМ по порожньому місцю на полі\n- Видалити вершину: ПКМ по вершині\n- Перемістити вершину: ЛКМ по вершині та тягнути мишею\n- Вибір вершини: ЛКМ по вершині (виділяється для додавання ребра)\n\n- Додати ребро: виділіть вершину, потім ЛКМ+Ctrl по іншій вершині\n- Видалити ребро: ПКМ по середині ребра\n- Редагувати вагу/дані ребра: подвійний ЛКМ по середині ребра (лише для вагового графа)\n- Вибір ребра: ЛКМ по середині ребра (для деяких дій)\n\n--- НАЛАШТУВАННЯ ---\n- Орієнтованість, ваговість, автоназва вершини: тумблери над полотном\n- Автоматична назва: якщо вимкнено — при створенні вершини з'явиться діалог для введення назви\n\n--- ІМПОРТ/ЕКСПОРТ ---\n- Експорт у .json/.txt: відповідні кнопки під полотном\n- Імпорт з .json: кнопка під полотном\n\n--- ВИБІР ГРАФА ---\n- Кнопка 'Вибрати граф' під полотном відкриває вікно для вибору, створення, перейменування, видалення або копіювання графів.\n- Можна працювати з кількома графами у межах однієї сесії.\n\n--- АНАЛІЗ ---\n- Вкладки під полотном: найкоротші шляхи, остовні дерева, спеціальні шляхи, обхід, потоки\n- Для алгоритмів обирайте вершини зі списків\n\n--- ДОДАТКОВО ---\n- Інструкція: ця кнопка\n- Всі дії супроводжуються підказками та повідомленнями про помилки\n\nПочніть з додавання вершин!",
    "ok_button": "OK"
  },
  "theme_select_dialog": {
    "window_title": "Вибір теми",
    "style_label": "Оберіть стиль теми:",
    "color_label": "Оберіть колір теми:",
    "modern": "Сучасна",
    "classic": "Класична",
    "dark": "Темна",
    "light": "Світла",
    "green": "Зелена",
    "blue": "Синя",
    "red": "Червона",
    "yellow": "Жовта",
    "ok_button": "OK"
  },
  "vertex_edit_dialog": {
    "window_title": "Редагування вершини",
    "vertex_name_label": "Назва вершини:",
    "additional_data_label": "Додаткові дані вершини (ключ-значення):",
    "key_label": "Ключ:",
    "value_label": "Значення:",
    "ok_button": "OK",
    "cancel_button": "Скасувати",
    "vertex_data_info": "Дані вершини{node_info} після редагування: {data}"
  },
  "common_dialogs": {
    "ok_text": "ok",
    "select_text": "вибрати"
  }
}